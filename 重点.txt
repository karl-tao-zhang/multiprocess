

1.问题总结：
  1.osi模型
  2.三次握手和四次挥手
  3.tcp和udp的区别
2.tcp 先建立连接再进行交互
  暂时实现不了连接其他端口
3.网络收发缓冲区

*缓冲区的功能： 协调读写速度，减少和磁盘交互

recv和send实际上是从缓冲区内获取内容，和向缓冲区发送内容
 recv缓冲区内有内容就不会阻塞 没内容就会阻塞！！
 send缓冲区是满了以后会阻塞！！
4.listen是为了建立连接 不写listen ，accept会出错


5.如果复制文件是在父进程打开文件 父子进程用的是同一个文件
 复制文件在各自的子进程中打开文件 父子进程用的是两个不同的文件

6.pipe是单向管道 fd1只能读 fd2只能写 如果换下位置就可以 就是第一个位置的只能读 第二个位置的只能写

7.queue1.py 取名字不要取queue 容易与python内建函数冲突

8.q = Queue(3)

q.put(1)
sleep(0.1)
print(q.empty())
print(q.full())

判断太快 而存消息比较慢 所以会判断为空

9.异步执行 就是交给内核一个任务 内核和应用程序同时执行就是异步

程序执行的同步和异步
同步：按照步骤一步一步顺序执行
异步：在程序执行中利用内核，不影响应用层程序持续执行

*信号是唯一的异步通信方式 （异步执行的就这一个）


10.
线程

什么是线程

线程也是一种多任务编程的方式，可以使用计算机多核资源。线程 又被成为轻量级的进程

线程特征

*线程是计算机核心分配的最小单位
*一个进程可以包含多个线程
*线程也是一个运行过程，也要消耗计算机资源。多个线程共享其进程的资源和空间
*线程也拥有自己特有的资源属性，比如指令集，TID等
*线程无论创建还是删除还是运行资源消耗都小于进程
*多个线程之间并行执行，互不干扰

11.python线程的GIL问题（全局解释器锁）

python -->支持多线  -->同步互斥 -->加锁 -->超级锁（给解释器加锁）

后果：一个解释器，同一时刻只能解释一个线程 ，  并行变成了并发，大大降低了python多线程的执行效率。

Python的GIL问题  解决方案
*尽量使用进程
*不使用c作为解释器  c#  java解释器
*python线程适用于高延迟的IO操作，网络操作，不适合cpu密集型或者传输速度很快的IO操作

12.路径后边加个斜线


























