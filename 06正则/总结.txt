1.正则表达式不能检索有重复的 比如 abcd要检测 abc和bcd这样是不行的
2.正则表达式要注意不要写空格 空格也算一个检测符号
3.fo* *表示可以重复0次或者多次 出现*会与前面的一个字符绑定在一起  0次是指f 而不是fo  fo表示一次
4.[]匹配括号范围内的任意一个字符  一定是一个 注意是一个
5.匹配字符集合
元字符 : [^...]
匹配规则 : 匹配除指定字符集之外的任意字符
这个^是在中括号里面的 是指除了之外的如果^在中括号外面是指 字符串的开头    在里面这个依然只能匹配一个字符
6.\0 是底层用c写的 用于末尾  认为是字符串结尾属于这种空字符 但是显示不出来
7.‘ok\?’,'are you ok?'
  如果不加\的话会检测出来o ok 不会出来? 这里?会当成字符 表示前一个元素的0个或者1个 如果加上转义字符\的话这个？就是？ 就可以被检测出来
8.在python中识别不了ok\?但是python比较智能会自动认为你是想转义  认为你是要用正则
9.\\\\\"hi\\\\\"
10.\t \n 在python里面没有所以会自己认为你要用正则 但是\r在python里面是有的所以你需要自己再加\      
r ----raw字符串：原生字符串，字符串的内容就是字符串本身，不进行任何转义处理
11.*  +  ?  {m,n}    这四种情况下会产生贪婪模式
非贪婪  *?  +?  ??  {m,n}  ?    思考一下就不贪婪了
12.子组使用的注意事项
1.每个正则表达式可以有多个子组,由外到内由左到右到右为第一第二＞……子组
2.子组通常不要交叉
In [2]: re.findall("a(bc(d)ef)",'abcdef')
Out[2]: [('bcdef', 'd')]
13.r'.+(\.com|\.cn)' 加上括号显示出来的才是整个的邮箱  如果不加括号显示出来的只能是 .com或者.cn 并没有前面的内容
14.findall返回的是数组而search  .group()返回的是字符串 如果只是search没有group搜索的是目标对象而加上group则是字符串 目标名字
15.sub 返回的是目标字符串
   subn 返回的是一个元组  在sub返回上多了一个替换的个数
16.match很容易出异常 出异常后属性就都不能用了，就无法调用属性了，这个要注意  注意处理  注意属性
17.compile 对象特有属性（re模块没有）
flags ： 标志位
pattern ： 正则表达式
groupindex  ： 捕获组形成的字典
groups ： 多少个子组
18.r'-?\d+\.?/?\d*%?' 匹配各种数字什么样的都有
19.flags 标志位赋值
I == IGNORECASE   忽略大小写
S == DOTALL 元字符.匹配\n
M == MULTILINE 元字符 ^ $ 可以以匹配每行的开头结尾
X == VERBOSE 可以给正则添加注释
多个标志位可以用|隔开
flags = re.
















