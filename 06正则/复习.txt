目标
1.熟练掌握正则表达式符号
2.能够看懂或者简单编写基本的正则表达式
3.能够使用python操作正则表达式

特点：
*方便进行检索修改文本的操作
*支持编程语言众多
*使用灵活多样

re.findall(pattern, string)

元字符(即正则表达式中有特殊含义的符号)
1.普通字符
元字符 : abc
匹配规则 : 匹配相应的普通字符
2.或
元字符 : ab|cd
匹配规则 : 匹配 | 两边任意一个正则表达式符合的情况
* | 两侧不要有没用的空格
3.匹配单一字符
元字符 :  .  
匹配规则 : 匹配出了换行之外的任意字符
f.o  --->   foo   fao    f@o
4.匹配开始位置
元字符 :  ^
匹配规则 ： 匹配一个字符串的开始位置
^Hello  ---> Hello  world  : Hello
5.匹配结束位置
元字符 : $
匹配规则 : 匹配目标字符串的结束位置结束位置
py$  --->  hello.py
6.匹配重复
元字符 : *
匹配规则 : 匹配前面的正则表达式重复0次或多次
fo*  --->  fo  foo  fooooooo  f
7.匹配重复
元字符 : +
匹配规则 : 匹配前面的正则表达式重复1次或多次
ab+ --->  ab  abbb  abbb
8.匹配重复
元字符 : ?
匹配规则 : 匹配前面的正则表达式重复0次或1次
ab?  --->  a  ab
9.匹配重复
元字符 : {n}   #n数字
匹配规则 : 匹配重复次数
ab  {3} --->  abbb
10.匹配重复
元字符 : {m, n}
匹配规则 : 匹配前面的正则表达式重复 m次 到 n次
ab{3, 5}  --->  abbb   abbbb  abbbbb
11.匹配字符集合
元字符 : []
匹配规则 : 匹配括号范围内的任意一个字符
[abcd123d]  --->  a  b  c  1  2  3  d
12.匹配字符集合
元字符 : [^...]
匹配规则 : 匹配除指定字符集之外的任意字符
13.匹配任意(非)数字字符
元字符 : \d   \D
匹配规则 : \d 匹配任意数字字符        [0-9]
          \D 匹配任意非数字字符    [^0-9]
14.匹配(非)普通字符  (普通字符 : 数字字母下划线)
元字符 : \w      \W
匹配规则 : \w  匹配任意一个普通字符       [_0-9a-zA-Z]  
          \W  匹配任意非普通字符         [^\w_0-9a-zA-Z]
                                       [^_0-9a-zA-Z]
15.匹配(非)空字符
元字符 : \s         \S
匹配规则 : \s 匹配任意空字符    \S 匹配任意非空字符
                 [ \n\t\r]                  []
16.匹配起始位置
元字符 : \A      \Z
匹配规则 : \A匹配开始位置    \Z匹配结束位置

相当于      ^                           $

绝对匹配 : \Aabc\Z  --->  abc (且字符串只是abc)
17.匹配(非)单词边界位置
元字符 : \b      \B
匹配规则 : \b 匹配单词的边界   
                 \B 匹配非单词的边界
单词边界 : 数字字母下划线和其他字符的交界位置为单词的边界
abc_1 haha

元字符总结 :***************
匹配单个字符 : （普通字符  a）     .    \d    \D    \w    \W    \s    \S    [...]    [^...]
匹配重复性 ： *    +    ？    {n}    {m, n}
匹配某个位置 ： ^    $    \A    \Z    \b    \B
其他 : |    ()    \

转义字符
正则表达式特殊符号 :  
.    *    ?    $    ' '    ""    []    {}    ()    \    ^
如果想匹配特殊符号则加转义
\"\.\"  --->   "."
r ---> raw  原生字符串 : 不进行转义

转义字符
正则表达式特殊符号 :  
.    *    ?    $    ' '    ""    []    {}    ()    \    ^
如果想匹配特殊符号则加转义
\"\.\"  --->   "."
r ---> raw  原生字符串 : 不进行转义

正则表达式分组
使用()可以分为一个正则表达式建立一个子组.子组可以看做内部的整体
abcd(ef)   --->  abcdef
abcdef ----》 http://www.baidu.com
子组的作用
1.增加子组后对正则表达式整体的匹配内容没有影响
2.子组可以改变重复元字符的重复行为
3.子组在某些操作中可以对子组匹配内容单独提取

子组使用的注意事项
1.每个正则表达式可以有多个子组,由外到内由左到右到右为第一第二＞……子组
2.子组通常不要交叉
In [2]: re.findall("a(bc(d)ef)",'abcdef')
Out[2]: [('bcdef', 'd')]

捕获组和非捕获组(命名组和非命名组)
子组命令格式
(?P<name>abc)
1.很多编程接口可以直接通过名字获取子组匹配内容
2.捕获组中的正则表达式可以通过名字重复调用
（?P=name）

(?P<dog>ab)cedf(?p=dog  --->   abcdefab)

re模块
obj = compile(pattern,flags = 0)
功能 : 获取正则表达式对象
obj.findall(string,pos,endpos)
功能 : 通过正则表达式匹配字符串
* 如果正则表达式有子组则只显示子组匹配内容
obj.split(string)
功能 : 按照正则表达式切割目标字符串
obj.sub(replaceStr, string, max)
功能 : 替换正则表达式匹配到的内容
subn(repl,string,count)
功能 : 替换正则表达式匹配到的内容
re.finditer(pattern,string)
功能  ： 使用正则表达式匹配目标内容
re.match(pattern,string)
功能 ： 匹配一个字符串的开头
re.search(pattern,string)
功能 ： 匹配一个字符串
* match 只能匹配字符串的开头位置，search可以匹配任意位置，但是也只能匹配一处
* 通常match对象调用其属性时往往需要try异常处理
fullmatch()
要求目标字符串完全匹配
compile 对象特有属性（re模块没有）
flags ： 标志位
pattern ： 正则表达式
groupindex  ： 捕获组形成的字典
groups ： 多少个子组

match 对象属性方法

print(match_obj.pos)  #目标字符串开头位置
print(match_obj.endpos) # 目标字符串结束位置
print(match_obj.re)  # 正则表达式对象
print(match_obj.string) # 目标字符串
print(match_obj.lastgroup) # 最后一组的名字
print(match_obj.lastindex) # 最后一组是第几组

span()     匹配到内容的起止位置
start()  匹配到内容的开始位置
end()   匹配到内容的结束位置

group(n)
功能 ： 获取match 对象匹配的内容
groups()
功能 ： 得到所有子组匹配的内容
groupdict()
功能 ：得到所有捕获组匹配的内容

(.    *    ?    $    ' '    "" 当正则表达式中要匹配  \  *  .  ?  {}  []  ()  "  '  这些字符是需要使用  '\' 进行转义。此时如果为了避免字符串 解析为 正则表达式 带来的麻烦,最好使用rew字符串)


*注意
In [33]: re.findall("[1\d{10}]","17611665537")
Out[33]: ['1', '7', '6', '1', '1', '6', '6', '5', '5', '3', '7']

In [34]: re.findall("1\d{10}","17611665537")
Out[34]: ['17611665537']
















