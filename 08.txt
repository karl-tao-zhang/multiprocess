线程通信
  通信方法：多个线程共用进程空间，所以进程的全局变量对进程内的线            程均可见。因此使用全局变量通信是线程主要通信方法。
  
  注意事项：线程间通信更容易产生资源争夺，往往需要同步互斥机制保              证通信安全
线程的同步互斥

线程的Event事件

操作：
  e = threading .Event()
  e.wait([timeout]) 如果e为设置状态则不阻塞，未设置则阻塞
  e.set()   将e变为设置状态
  e.clear()  将e设置去除


线程锁          这里没听！

lock = threading.Lock()创建锁
lock.acquire()上锁
lock.release()解锁

操作原理：重复上锁acquire()会阻塞


python线程的GIL问题（全局解释器锁）

python -->支持多线  -->同步互斥 -->加锁 -->超级锁（给解释器加锁）

后果：一个解释器，同一时刻只能解释一个线程 ，  并行变成了并发，大大降低了python多线程的执行效率。

Python的GIL问题  解决方案
*尽量使用进程
*不使用c作为解释器  c#  java解释器
*python线程适用于高延迟的IO操作，网络操作，不适合cpu密集型或者传输速度很快的IO操作 

注意：线程遇到阻塞会让出解释器


Line cpu: 8.961792230606079
Line IO ：3.9131791591644287

Thread cpu: 9.47533917427063
Thread IO ：3.84561351654653

Process cpu：4.48289343786621
Process IO： 2.1754744052886963


结论：进程的效率明显提高  由于GIL影响线程效率较低


进程和线程的区别和联系
1.两者都是多任务编程的方式，都能够使用计算机多核资源
2.进程的创建和删除要比线程消耗更多的计算机资源
3.进程空间独立，数据安全性好，有专门的通信方法
4.线程使用全局变量通信，更加简单，但是往往需要同步互斥操作
5.一个进程可以包含多个线程，线程共享进程的资源
6.进程线程都有自己的特有属性资源，如命令，属性，id等

使用场景：
*如果需要创建较多的并发，任务比较简单，线程比较合适
*如果数据操作和功能比较独立，此时使用进程比较合适
*使用线程时要考虑到同步互斥的复杂 程度
*python线程需要考虑到GIL问题




总结：
1.进程线程的特征
2.进程线程区别和关系
3.同步互斥的意义，用过什么方法，什么情况下用的
4.进程间通信方式都知道哪些，有什么特点
5.僵尸进程怎么褚经理，线程的GIL问题怎么看
6.给一个情景，问选择进程还是线程，为什么



服务器模型


硬件服务器: 主机  集群
厂商：IBM  HP　　联想　　浪潮　　

软件服务器: 网络服务器 在后端提供网络功能,逻辑处理,数据处理的程序
                    或者架构等
分类：webserver  -->网站后端程序提供网站请求的后端处理和响应
例如  httpserver  django  flask -----》处理HTTP请求，回复http响应
      邮箱服务器 --->处理邮件
      文件处理器---> 处理文件传输

功能：网络连接，逻辑处理，数据交互，数据传输，协议的实现

服务器架构: c/s  (客户端服务器)
            b/s  (浏览器服务器)
            服务器的组织形式

服务器追求: 处理速度更快,数据更安全,并发量更大

硬件: 更高配置  集成分布基础  更好的网路速度 更多主机 更好的网路安全性

软件: 程序占有更少的资源,更流畅的运行,处理更多的并发

基本的服务器模型

循环服务器：单进程程序，循环接收客户端请求，处理请求，每处理完一个请求再去接收下           一个请求
优点：实现简单，占用资源少

缺点：无法同时连接多个客户端，当一个客户端长期占有服务器时，形成其他客户端无法完成的情况

使用情况：任务比较短暂，udp套接字更合适

并发服务器：同时处理多个客户端的任务请求

IO并发：IO多路复用 协程

优点：资源消耗少，效率较高，适用于IO类型服务器

缺点：不能监控cpu密集型程序，本质是单进程所以不能长期阻塞消息的收发

多进程/多线程并发：为每一个客户端单独提供一个进程或者线程处理请求。由于进程线程执
                   行独立所以对其他进程不会有影响

		优点：客户端可以长期占有服务器，操作不会对其他进                      程线程产生影响
		缺点：消耗资源较多

多进程并发

基于fork的多进程并发
1.创建套接字  绑定  监听
2.接收客户端请求  accept
3.创建子进程处理客户端请求,
   父进程继续准备接收新的客户端连接
4.客户端退出,销毁相应的子进程


见服务器代码


TFTP文件服务器

(要求多客户端同时操作)

功能要求：
*客户端有简单的命令提示界面
*根据提示选择相应的功能
	1.查看服务器文件库的文件列表（只显示普通文件）
	2.下载其中的某个文件到本地       用tcp
	3.可以将本地文件上传到文件库中
	4.退出
*服务器需求：
	1.处理客户端各种请求
	2.允许多个客户端同时访问操作


文件的上传,下载,和服务端文件库的查看

服务端                    客户端
                        1.查看文件库中有哪些文件
                        2.下载文件到本地
                        3.将本地文件上传到文件库

1.技术分析 
	用什么套接字            tcp
	需要什么服务器模型      多进程并发
	需要注意的问题          粘包 僵尸进程
	数据如何传输            文件名传输  注意粘包处理
2.设计整体结构
	要求封装为类，将功能函数写类中，
	

	class TFTPServer():
	    def  __init__():
	       交互套接字
	    def do_list():
            def do_get():
            def do_put():
        
        main（）函数控值整体流程
           创建套接字
           接收客户端连接
           创建子进程
           父进程继续等待连接




fork --- 多进程
tcp   socket

粘包

os.listdir(path)
获取该文件夹下所有文件,形成一个列表

os.path.isfile(path)
os.path.isdir(path)
判断一个文件是否是普通文件/文件夹



作业: 完成tftp文件服务器  get 和 put功能


作业：1.客户端框架完成与服务器交互
      2.写get或者put




650924099























