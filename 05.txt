进程相关函数使用

os.getpid()
功能：获取当前进程的PID号
返回值：返回PID号

os.getppid()
功能：获取父进程的进程号

os._exit(status)
功能：退出进程
参数：进程的退出状态  整数

sys.exit([status])
功能：退出程序
参数：默认为0  如果是整数则表示退出状态
               如果是字符串则表示退出时打印内容

*sys.exit 可以通过捕获systemExit异常

孤儿过程：父进程先于子进程退出，此时子进程就会成为孤儿进程。
*孤儿进程会被系统指定的进程收养，即系统进程会成为该孤儿进程新的父进程

僵尸进程：子进程先于父进程退出，父进程没有处理子进程退出状态，此时子进程成为僵尸进程

*僵尸进程已经结束，但是会滞留部分PCB信息在内存，大量的僵尸会消耗系统资源，应该尽量避免

*父进程先退出
*父进程处理子进程退出状态

pid,status = os.wait()
功能：在父进程中阻塞等待处理子进程的退出
返回值： pid 退出的子进程的PID号
         status  子进程的退出状态 

pid,status = os.waitpid(pid,potion)
功能：同wait
参数：pid -1 表示任意子进程退出
          >0 整数 指定PID号的子进程退出
      option  0 表示阻塞等待
              WNOHANG 表示非阻塞
返回值： 同wait

waitpid(-1,0)   ==========wait()


*父进程先退出
 创建二级子进程
   1.父进程创建子进程等待子进程退出
   2.子进程创建二级子进程，然后马上退出
   3.二级子进程成为孤儿，处理具体事件



***************************************
# 写一个聊天室

# 功能：类似qq群聊

# 1.进入聊天室需要输入用户名
# 2.有人进入聊天室，其他人会收到提示
#    xxx进入聊天室
# 3.某人发消息，则其他人都能收到
#   xxx说： xxxxxxxx
# 4.有人退出聊天室 其他人会收到提示
#  xxx退出了聊天室
  5.管理员功能，管理员喊话聊天室所有人均可收到

# 服务端和客户端
# *整体实现方案
# *用什么技术

先弄框架
1.用什么技术

socket通信 --->消息转发  -----> UDP通信

转发模式  ---->每个将消息发送给服务器，服务器发送给每个成员

消息收发  ---->使用多进程让发送和接受互不影响

存储在于  ---->字典或者列表
               姓名，地址

注意： 使用一定的封装性 
       测试，每个功能进行测试   


2.代码编写步骤

先搭建网络连接  --> 多进程创建 --> 每个功能编写 --> 功能测试

客户端
 *登录 “L name”
   服务器：识别请求 判断是否可以登录
           保留用户
           将登录消息通知其他人
 *聊天  "C message"
   服务器：识别请求
           将消息转发给其他人
 *退出  “Q name”
    服务器：识别请求
            告知其他人退出
            从结构中删除用户

服务器
 
3.进行编码
 搭建框架

shift + alt =8  两个编程

multiprocessing 模块创建进程

1.需要将要做的事情封装为函数
2.使用multiprocessing中提供的process类创建进程对象
3.通过进程对象和Process初始化函数 对进程进行设置，并绑定要执行的事件
4.启动进程，会自动执行相关联函数
5.事件完成后回收进程

创建进程对象

Process（）
功能：创建进程对象
参数：name：给创建的进程对象起一个名字
            默认Process-1
      target：绑定的函数
      args：元组 给target函数按照位置传参
      kwargs：字典 给target函数按照键值传参
      
p.start()
功能：启动进程，此时进程被创建。自动运行进程函数

p.join([timeout])
功能：阻塞等待回收响应的进程
参数：超时时间

*multiprocessing创建进程是原来进程的子进程，创建后父子进程各自执行互不影响
*子进程同样是复制父进程的空间，子进程对内容的修改不会影响父进程空间
*join回收子进程，会有效的组织僵尸进程产生

作业：multiprocess对照fork
      
      创建父子进程，复制一个文件，父子进程各复制一半到一个新的文件中


进程池 进程间通信

















